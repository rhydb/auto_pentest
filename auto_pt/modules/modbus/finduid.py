# Author: Rhydian Brown
from scapy.all import *
import scapy.contrib.modbus as modbus
import socket

from queue import Queue
import threading

from auto_pt.core.modules import Exploit, Option, Likelihood, Impact, text_color
from auto_pt.core.reports import Report
from auto_pt.core.parsers import parse_ip

transId = 1

def getTransId():
	global transId
	transId = transId + 1
	if transId > 65535:
		transId = 1
	return transId

class Module(Exploit):
    name = "Modbus UID discovery"
    desc = "Finds UIDs available on a Modbus host"

    likelihood = Likelihood.UNLIKELY
    impact = Impact.SEVERE

    def __init__(self):
        super().__init__()
        self.options = {
                "RHOSTS": Option([], True, "Remote hosts", type=parse_ip),
                "UID_FROM": Option(0, True, "Start UID", type=int),
                "UID_TO": Option(255, True, "End UID", type=int),
                "THREADS": Option(1, True, "Number of threads to run", type=int),
                "TIMEOUT": Option(5, True, "Timeout allowance for a connection", type=int),
                "PORT": Option(502, True, "Port number", type=int),
                }
        self.results = []
        self.con = None

    def accept_input(self, data):
        if isinstance(data, list):
            self.options["RHOSTS"].set([ip for ip, port in data])
            self.options["PORT"].set(data[0][1])

    def write_report(self, report: Report):
        mitigation = [
                "Implement a firewall",
                "Use a VPN to encrypt communication across networks",
                "Isolate the Modbus network"
                ]


        num_uids = self.get_option("UID_TO") - self.get_option("UID_FROM")
        num_hosts = len(self.get_option("RHOSTS"))
        _ = report\
                .heading(self.name)\
                .paragraph("Risk: " + report.background(self.severity_colour, report.colour(text_color(self.severity_colour), str(self.severity))))\
                .paragraph(self.desc)
        if self.results:
            report.found_something = True
            # collect all UIDs for each host
            comma_results = {}
            for rhost, uid in self.results:
                uid = str(uid) # convert to string so that they can be joined
                if comma_results.get(rhost):
                    comma_results[rhost].append(uid)
                else:
                    comma_results[rhost] = [uid]

            (
                report.paragraph("Mitigation strategies:")
                    .list(mitigation)
                    .paragraph("Results from scanning " + str(num_uids) + " UIDs on " + str(num_hosts) + " hosts:")
                    # join the uids for each host
                    .table(["Host", "UID"], [[rhost, ','.join(uids)] for rhost, uids in comma_results.items()])
            )
        else:
            report.paragraph("No results to report")

    def is_valid(self):
        if not super().is_valid():
            return False

        if self.options["UID_FROM"].value > self.options["UID_TO"].value:
            print("UID_FROM must be less than UID_TO")
            return False
        return True

    def try_uid(self, rhost, uid):
        print("trying", rhost, uid)
        port = self.get_option("PORT")
        timeout = self.get_option("TIMEOUT")

        with socket.socket() as s:
            try:
                s.connect((rhost, port))
            except (OSError, ConnectionRefusedError):
                return

            # todo: bind to source ip
            con = StreamSocket(s, Raw)

            transId = getTransId()
            ans = con.sr1(
                    modbus.ModbusADURequest(transId=transId, unitId=uid) / modbus.ModbusPDU04ReadInputRegistersRequest(),
                    timeout=timeout, verbose=0)

            if ans:
                first_four = bytes(ans)[:4]
                expected = transId.to_bytes(2) + bytes(2) # trans id + protocol id, modbus protocol id is always \x00\x00
                if first_four == expected:
                    self.results.append([rhost, uid])
                    print("UID up:", uid)


    def worker(self, rhost, queue):
        while not queue.empty():
            uid = queue.get()
            self.try_uid(rhost, uid)
            queue.task_done()

    def exploit(self):
        self.results = []

        rhosts = self.get_option("RHOSTS")

        thread_count = self.get_option("THREADS")

        for rhost in rhosts:
            queue = Queue()
            for i in range(self.options["UID_FROM"].value, self.options["UID_TO"].value):
                queue.put(i)

            threads = []
            for _ in range(thread_count):
                thread = threading.Thread(target=self.worker, args=(rhost, queue,))
                thread.start()
                threads.append(thread)

            for thread in threads:
                thread.join()

        return self.results
