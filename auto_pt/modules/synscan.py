# Author: Rhydian Brown
import ipaddress
from scapy.all import *
from queue import Queue
import socket

from auto_pt.core.modules import Exploit, Option, Likelihood, Impact, text_color
from auto_pt.core.reports import Report
from auto_pt.core.parsers import list_of_ports

class Module(Exploit):

    name = "SYN scan for open ports"
    desc = "Sends SYN packets to establish a connection and detect open ports"
    likelihood = Likelihood.MODERATE
    impact = Impact.MINOR

    def __init__(self):
        super().__init__()

        self.options = {
                "RHOST": Option(None, True, "Remote host", type=ipaddress.ip_address),
                "THREADS": Option(1, False, "Number of threads to run", type=int),
                "PORT": Option([502], True, "Ports to scan", type=list_of_ports),
                "TIMEOUT": Option(5, True, "Timeout to wait for a reply", type=int),
                "REPORT_CLOSED": Option(False, False, "Toggle to report ports that are closed", type=bool),
                }

        self.results = []

    def write_report(self, report: Report):
        self.results.sort(key=lambda x: x[1]) # sort by the port
        mitigation = [
                "Apply a filter to block malicious traffic",
                "Enforce whitelisting to prevent unknown devices from connecting",
                "Close all unused open ports",
                ]

        (
            report
                .heading(self.name)
                .paragraph("Risk: " + report.background(self.severity_colour, report.colour(text_color(self.severity_colour), str(self.severity))))\
                .paragraph(self.desc)
                .paragraph("Scanned " + str(len(self.get_option("PORT"))) + " ports")
        )
        if self.results:
            report.found_something = True
            (
                report
                    .paragraph(report.bold("Mitigation strategies:"))
                    .list(mitigation)
                    .table(["Host", "Port", "Status"], self.results)
            )
        else:
            report.paragraph("No results to report")


    def syn_scan(self, rhost, queue, timeout):
        while not queue.empty():
            port = queue.get()
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(timeout)

                result = s.connect_ex((rhost, port))

                is_open = result == 0
                report_closed = self.get_option("REPORT_CLOSED")

                if report_closed or is_open:
                    print(rhost, port, "Open" if is_open else "Closed")
                    self.results.append([rhost, port, "Open" if is_open else "Closed"])

            queue.task_done()

    def exploit(self):
        self.results = []

        rhost = str(self.get_option("RHOST"))
        thread_count = self.get_option("THREADS")
        timeout = self.get_option("TIMEOUT")

        queue = Queue()
        for p in self.get_option("PORT"):
            queue.put(p)

        threads = []
        for _ in range(thread_count):
            thread = threading.Thread(target=self.syn_scan, args=(rhost, queue, timeout))
            threads.append(thread)
            thread.start()

        for thread in threads:
            thread.join()

        return self.results
