# Author: Rhydian Brown
from .reader import ConfigReader
import yaml
from pathlib import Path
import auto_pt.core.modules

class YAMLConfigReader(ConfigReader):
    def __init__(self, path: Path):
        super().__init__(path)

        with self.path.open(encoding="UTF-8") as f:
            self.config = yaml.safe_load(f)

    def get_modules(self, config_modules):
        if isinstance(config_modules, dict): # yaml configs use dicts with just the name
            modules = []
            for name, options in config_modules.items():
                # rebuild the full module path
                full_path = Path("modules", name + ".py")
                module_class, short_name = auto_pt.core.modules.load_module(full_path)
                loaded_module = module_class()

                # load the options into the module
                for key, value in options.items():
                    if key == "modules":
                        # submodules
                        loaded_module.modules += self.get_modules(value)
                    else:
                        try:
                            loaded_module.options[key].set(value)
                        except ValueError as e:
                            print(f"Error setting option {key} for module {name}:", e)
                            exit(1)

                modules.append((loaded_module, name))
            return modules

        else:
            print("unsupported yaml config")
            exit(1)

    def get_option(self, key):
        return self.config.get(key)

    def set_option(self, key, value) -> None:
        self.config[key] = value

    def write(self):
        with self.path.open("w", encoding="UTF-8") as f:
            yaml.safe_dump(self.config, f)
