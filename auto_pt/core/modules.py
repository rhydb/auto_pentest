# Author: Rhydian Brown
from enum import Enum
from pathlib import Path
import importlib.util
from tabulate import tabulate

from .reports import Report

modules_dir = Path(__file__).parent.parent / "modules"

def find_modules(path = modules_dir):
    global modules_dir
    modules_dir = path
    p = Path(path)
    py_files = filter(lambda f: f.is_file(), p.rglob("*.py"))
    return py_files

def module_path(path):
    return path.relative_to(modules_dir).with_suffix('')

def load_module(path):
    module_name = path.stem
    spec = importlib.util.spec_from_file_location(module_name, path)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)

    # remove the first directory 'modules' and remove the suffix
    short = path.with_suffix('')
    return getattr(module, 'Module'), short # get the Module class


class Likelihood(Enum):
    CERTAIN = 5
    LIKELY = 4
    MODERATE = 3
    UNLIKELY = 2
    RARE = 1


class Impact(Enum):
    INSIGNIFICANT = 1
    MINOR = 2
    SIGNIFICANT = 3
    MAJOR = 4
    SEVERE = 5


class Option:
    def __init__(self, default, required, desc, type=None, validate=None):
        self.value = default
        self.required = required
        self.desc = desc
        self.type_cast = type
        self.validate = validate
        self.valid = True
        self.default = default

    def set(self, value):
        if self.type_cast is not None:
            try:
                self.value = self.type_cast(value)
            except ValueError:
                print("Invalid value:", value)
                self.valid = False
        else:
            self.value = value
    
    def is_valid(self) -> bool:
        if self.required and self.value is None:
            return False
        if self.validate:
            if not self.validate(self.value):
                return False
        return self.valid

    def to_json(self):
        return {
                "default": self.default,
                "required": self.required,
                "value": self.value,
                "desc": self.desc,
        }
        

def text_color(background_color):
    colour = background_color.replace('#', '')
    r = float(int(colour[:2], 16))
    g = float(int(colour[2:4], 16))
    b = float(int(colour[4:], 16))
    # Normalize the RGB values to [0, 1]
    r = r / 255.0
    g = g / 255.0
    b = b / 255.0
    
    luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b
    threshold = 0.5
    
    if luminance > threshold:
        return '#000000'
    else:
        return '#ffffff'

class Exploit:
    name: str = ""
    desc: str = ""
    likelihood: Likelihood = Likelihood.RARE
    impact: Impact = Impact.INSIGNIFICANT

    def __init__(self):
        self.modules: list['Exploit'] = []
        self.options = {}

    @property
    def severity(self):
        return self.likelihood.value * self.impact.value

    @property
    def severity_colour(self):
        colours = []
        colours += ["#39b34a"] * 2 # 1,2
        colours += ["#2d923c"] * 2 # 3,4
        colours += ["#f8eb13"] * 5 # 5,6,7,8,9
        colours += ["#f79325"] * 3 # 10,11,12
        colours += ["#e71719"] * 4 # 13,14,15,16
        colours += ["#ba1319"] * 9 # 17-25
        return colours[self.severity - 1]

    def is_valid(self) -> bool:
        for name, opt in self.options.items():
            if not opt.is_valid():
                print(name, "is invalid")
                return False
        print("module is valid")
        return True

    def exploit(self):
        return

    def write_report(self, report: Report):
        return

    def get_option(self, key: str):
        val = self.options[key]
        return val.value

    def accept_input(self, data):
        return

    def show_options(self):
        headers = ["Name", "Current Value", "Required", "Description"]
        table = []
        for name, option in self.options.items():
            table.append([name, option.value, option.required, option.desc])

        print(tabulate(table, headers=headers))

class IPOption(Option):
    def is_valid(self) -> bool:
        if not super().is_valid():
            return False
        try:
            ipaddress.ip_address(self.value)
        except ValueError:
            return False
        return True
