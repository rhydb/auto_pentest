# Author: Rhydian Brown
import argparse
from pathlib import Path

from tabulate import tabulate
import config

import auto_pt.core.modules
import auto_pt.core.reports

def report_type_from_file_name(file_name):
    return file_name.suffix.lstrip(".").lower()

parser = argparse.ArgumentParser(
        prog='AutoPT',
        description='Automatic Pen-testing'
        )

parser.add_argument('-c', '--config',
                    required=False,
                    type=Path
                    )

parser.add_argument('-o', '--report',
                    default="report",
                    required=False,
                    type=Path
                    )
args = parser.parse_args()

config_reader = None

if args.config:
    if args.config.is_file():
        try:
            config_reader = config.ConfigFactory(args.config)
        except ValueError as e:
            print("Error reading config:", e)
            exit(1)


        modules = config_reader.get_modules(config_reader.get_option("modules"))
        for mod, mod_name in modules:
            if not mod.is_valid():
                print(f"Module {mod_name} invalid")
                exit(0)
            if mod.modules:
                print("module has submodules:", mod.modules)

        # try to get the report type in this order:
        # 1. config file
        # 2. --report extension
        # 3. give a default
        report_type = config_reader.get_option("report") or \
            report_type_from_file_name(args.report)
        report = auto_pt.core.reports.ReportFactory(report_type) or auto_pt.core.reports.ReportFactory("html")
        if not report:
            print("Unknown report type:", report_type, "defaulting to html")
            report = auto_pt.core.reports.HTMLReport()
            report_type = "html"


        # summary of the report with just modules that flagged
        # found_something to True
        report_summary = []

        # all modules are valid, run them
        for mod, mod_name in modules:
            print("Running", mod_name)
            try:
                results = mod.exploit()
                if mod.modules and results:
                    print("running submodules")
                    for sub_mod, sub_mod_name in mod.modules:
                        print(f"{sub_mod=} {results=}")
                        sub_mod.accept_input(results)
                        sub_mod.exploit()
            except Exception as e:
                print("Exception while running", mod_name + ":", e)
                exit(1)
            report.found_something = False
            mod.write_report(report) # can modify report.found_something
            if report.found_something:
                report_summary.append(mod.name + ": " + mod.desc)

            if mod.modules:
                for sub_mod, sub_mod_name in mod.modules:
                    report.found_something = False
                    sub_mod.write_report(report)
                    if report.found_something:
                        report_summary.append(sub_mod.name + ": " + sub_mod.desc)

        if report_summary:
            summary_report: auto_pt.core.reports.Report = auto_pt.core.reports.ReportFactory(report_type)
            summary_report\
                    .heading("Summary of report")\
                    .paragraph("A summary of modules that found something of interest. This list may not include all modules executed.")\
                    .paragraph("Each module is given a risk score based ")\
                    .list(report_summary)
            report.text = summary_report.text + report.text
        with Path(args.report).open("w") as f:
            f.write(report.finish())
        exit(0)


selected_module = None

modules = []
for m in auto_pt.core.modules.find_modules():
    try:
        modules.append(auto_pt.core.modules.load_module(m))
    except Exception as e:
        print("Unable to load module:", m, e)

while True:
    prompt = "> "
    if selected_module:
        prompt = selected_module[1] + " " + prompt
    try:
        inp = input(prompt).strip().split()
    except KeyboardInterrupt:
        break

    match inp:
        case ["exploit"]:
            if not selected_module:
                print("Select a module with 'use'")
                break
            if selected_module[0].is_valid():
                selected_module[0].exploit()
        case ["exit"]:
            break
        case ["use"]:
            selected_module = None
        case ["use", name]:
            for module, path in modules:
                if name == path:
                    selected_module = (module(), path)
                    break
            else:
                selected_module = None
                print("Cannot find module. Use 'show modules'")
        case ["show", subject]:
            if subject == "modules":
                headers = ["Name", "Description"]
                table = []
                for module, path in modules:
                    table.append([path, module.desc])
                print(tabulate(table, headers))
            elif subject == "options":
                if not selected_module:
                    print("select a module using 'use'")
                    continue
                selected_module[0].show_options()

        case ["report", report_type]:
            if selected_module:
                report = auto_pt.core.reports.ReportFactory(report_type)
                if not report:
                    print("Unknown report type")
                report = selected_module[0].write_report(report)
                print(report.finish())

        case ["set", key, value]:
            if selected_module is None:
                print("Select a module using 'use'")
                continue
            opt = selected_module[0].options.get(key.upper())
            if not opt:
                print("Unknown option")
                continue
            try:
                opt.set(value)
            except ValueError:
                print("Invalid")

