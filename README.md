# Setup

Create and activate a virtual environment. Minimum Python version 3.10.

```
pip -m venv .venv
source .venv/bin/activate
pip install -r requirements.txt
```

You will also need to install the tool itself for use in the web app. In the
directory with the `pyproject.toml`:

```
pip install -e .
```

This should then be listed in `pip freeze` as:

```
-e /home/kali/auto_pt
```

## Main tool

The main tool is located in the `auto_pt` directory. `main.py` is the main
executable and should be passed `--config <config_file>` to run.

An example configuration file in YAML:

```yaml
report: "html"
modules:
  modbus/discover:
    RHOSTS: "192.168.0.0/28"
    PORT: 502
    THREADS: 20
    modules:
      modbus/finduid:
        UID_FROM: 0
        UID_TO: 10
        THREADS: 10
```

and another in JSON:

```json
{
    "report": "latex",
    "modules": [
        {
            "name": "modbus/discover",
            "options": {
                "RHOSTS": "192.168.0.0/28",
                "PORT": 502,
                "THREADS": 20,
                "modules": [
                    {
                        "name": "modbus/finduid",
                        "options": {
                            "UID_FROM": 0,
                            "UID_TO": 10,
                            "THREADS": 10
                        }
                    }
                ]
            }
        }
    ]
}
```

## Web app

The web app also requires the virtual environment to be active and all dependencies installed.

Run `run.py` and this should start the flask app and create the local database file.

## Docs

The example modules should be enough to create new ones but the basic premise
is:

* Modules are in their own file under a directory (sub-directories are supported)
* They provide a class `Module` that inherits from `Exploit` found in `core/modules.py`
* The defined a dict `options` that maps keys to an `Option` object
* They provide the basic data set out in `Exploit`
* The `exploit` method is the main exploit to be ran
* The `write_report` method adds their report onto an existing report by calling its builder methods. Modules do not call `report.finish`

Additional configuration files can be supported by providing a class that
inherits `ConfigReader` in `config/reader.py` and adding this class and its
extension to the `ConfigFactory` in `config/__init__.py`. The main loading
behaviour should be located in `get_modules` where all modules are loaded and
parsed into actual `Module` objects.

Additional report formats can be supported by providing a class that inherits
`Report` found in `core/reports.py`. This is a builder class that provides
methods that successively add onto the internal text until `finish` is called
which compiles the report and resets the class until `finish` is called which
compiles the report and resets the class. This new class should also be added
to the `ReportFactory` found in the same file along with its report type that
should be provided in config files.

Looking at `LatexReport` as an example, it is recommended to store any header
or footer information within the class itself and add this on by overriding
`finish()`. The `found_something` flag is used to indicate whether a particular
Module should be included in the summary. This is reset between calls to
`exploit` and should not be modified by the Report class itself.
